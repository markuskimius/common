#!/bin/bash

##############################################################################
# COMMON: Unix utilities
# https://github.com/markuskimius/common
#
# Copyright (c)2020-2021 Mark Kim
# Released under GNU General Public License version 2.
# https://github.com/markuskimius/common/blob/main/LICENSE
##############################################################################

function usage() {
    cat <<EOF
Usage: ${SCRIPTNAME} [OPTIONS] COMMAND [ARGUMENTS]

COMMAND:
  cfg [FILENAME]        Read FILENAME and print its consolidated output.  If
                        the FILENAME contains no path separator, it is assumed
                        to be a file in \$CAFE/*/etc.  The FILENAME may be a
                        glob.

  test                  Test the environment to ensure it has all dependencies
                        required by COMMON.

  bashrc                Generate and output the name of the bashrc to source by
                        cronjobs.

  python3 [ARGUMENTS]   Call python3 with [ARGUMENTS].  If the python3 is not
                        installed, python is called instead.

  crontab               Show the crontabs of active packages.

    -d,--diff           Diff the crontabs of active packages against the
                        installed crontab.

    -i,--install        Install the crontabs of active packages.

EOF
}


##############################################################################
# PROGRAM BEGINS HERE

source "logger.sh" || exit 1


SCRIPTNAME=$(basename -- "$BASH_SOURCE")
SCRIPTPATH=$BASH_SOURCE
SCRIPTARGV=( "$@" )


function main() {
    local command=()
    local lock=0
    local isok=1

    # Execute the command
    case "$1" in
        cfg)            shift && action=( cfg-command       )           ;;
        test)           shift && action=( test-command      )           ;;
        bashrc)         shift && action=( bashrc-command    ) && lock=1 ;;
        python3)        shift && action=( python3-command   )           ;;
        crontab)        shift && action=( crontab-command   )           ;;
        help)           shift && action=( usage             )           ;;
        *)              logger FAIL "${1}: Invalid command"
                        isok=0
    esac

    # Ensure core dependencies are met
    ensure-deps || isok=0

    # Sanity check
    if (( ! isok )); then
        usage 1>&2
        exit 1
    fi

    # Lock
    if (( lock )); then
        lock-workdir || exit 1
    fi

    "${action[@]}" "$@"
}


function cfg-command() {
    python3-command "${DPM}/common/lib/common_cfg.py" "$@"
}


function bashrc-command() {
    local dpm=$(command -v dpm)
    local bashrc="${WORKDIR}/.bashrc"
    local isok=1

    # Sanity check
    [[ -z "$dpm"     ]] && logger ERROR "\$dpm not set" && isok=0
    [[ -z "$DPM"     ]] && logger ERROR "\$DPM not set" && isok=0
    [[ -z "$WORKDIR" ]] && logger ERROR "\$WORKDIR not set" && isok=0

    if (( isok )); then
        printf "[[ -z \"\${DPM-}\" ]] && eval \"\$(%q setup)\"\n" "$dpm" > "$bashrc" || isok=0
    fi

    if (( isok )); then
        printf "%s\n" "$bashrc"
    fi

    (( isok ))
}


function test-command() {
    source "colorize.sh" || exit 1

    local commands=(
        basename cat crontab dirname env git grep hostname jq netstat ps
        sort tac timeout tput whoami
    )
    local vars=( DPM HOME HOSTNAME USER WORKDIR )
    local isok=1
    local tmp

    function checking() {
        printf "%-44s" "Checking $1 ..."
    }

    function pass() {
        printf "["
        colorize green PASS 1
        printf "]\n"
    }

    function fail() {
        printf "["
        colorize red FAIL 1
        printf "]\n"
        isok=0
    }

    # variables
    for tmp in "${vars[@]}"; do
        checking "environment variable \$$tmp"
        declare -p "$tmp" &>/dev/null && pass || fail
    done

    # commands
    for tmp in "${commands[@]}"; do
        checking "command $tmp"
        command -v "$tmp" &>/dev/null && pass || fail
    done

    # bash 4
    if true; then
        checking "bash is version 4 or later"
        (( "$(bash -c 'printf "%s" "${BASH_VERSINFO[0]}"')" >= 4 )) && pass || fail
    fi

    # enhanced getopt
    if true; then
        checking "getopt is enhanced"

        command -v getopt >/dev/null && getopt -T &>/dev/null
        (( $? == 4 )) && pass || fail
    fi

    # realpath
    if true; then
        checking "realpath or readlink -f"

        if command -v realpath >/dev/null; then
            pass
        elif command -v readlink >/dev/null && readlink -f . &>/dev/null; then
            pass
        else
            fail
        fi
    fi

    # python 3
    if true; then
        local version=$(python3-command --version 2>/dev/null)
        local number=${version##* }
        local major=${number%%.*}

        checking "python is version 3"
        [[ -n "$major" ]] && (( major == 3 )) && pass || fail
    fi

    (( isok ))
}


function python3-command() {
    local real=$(command -v python3 || command -v python)

    # Sanity check
    if [[ -z "$real" ]]; then
        logger FAIL "python3 not installed"
        return 1
    fi

    exec "$real" "$@"
}


function crontab-command() {
    source "getopt.sh" || exit 1

    local OPTOPT OPTARG
    local command=( crontab-cat )
    local isok=1

    # Process arguments
    while getopt-sh "di" "diff,install" "$@"; do
        case "$OPTOPT" in
            -d|--diff)    command=( crontab-diff )    ;;
            -i|--install) command=( crontab-install ) ;;
            *)            isok=0
        esac
    done

    # Sanity check
    if (( ! isok )); then
        return 1
    fi

    "$command" "${OPTARG[@]}"
}


function crontab-cat() {
    source "template.sh" || exit 1

    local activefile="${DPM}/.active"
    local active=()
    local pkgname
    local crontab
    local count=0

    # Header
    printf "%s\n" "$(repeat "#" 78)"
    printf "# Auto generated by '%s' on %s\n" "$SCRIPTNAME" "$(date)"
    printf "\n"

    # Get the list of active packages
    if [[ -r "$activefile" ]]; then
        active=( $(cat "$activefile") )
    fi

    # Cat their crontab contents
    for pkgname in "${active[@]}"; do
        crontab="${DPM}/${pkgname}/etc/crontab.shdoc"

        printf "%s\n" "$(repeat "#" 40)"
        printf "# Package '%s'\n" "$pkgname"
        template "$crontab"
        printf "\n"

        (( count+=1 ))
    done

    if (( count == 0 )); then
        printf "# No packages with crontab\n"
    fi
}


function crontab-diff() {
    diff "$@" <(crontab -l) <(crontab-cat)
}


function crontab-install() {
    # Show the diff first
    diff -u <(crontab -l) <(crontab-cat)

    # Install the new crontab
    logger INFO "Applying new crontab..."
    crontab-cat | crontab -
}


##############################################################################
# HELPER FUNCTIONS

function ensure-deps() {
    local isok=1

    [[ -z "$WORKDIR" ]] && logger ERROR "\$WORKDIR not set" && isok=0
    [[ -n "$WORKDIR" ]] && mkdir -p "$WORKDIR" || isok=0

    (( isok ))
}


function lock-workdir() {
    local lockfile="${WORKDIR}/.lock"
    local locked=0

    #
    # 'flock' is preferred but (1) it requires restarting the script and (2) it
    # may not be available on some systems.  This script must be written such
    # that (1) is not an issue.
    #
    # As for (2), we fall back on 'shlock' if 'flock' is not available.
    # 'shlock' is less preferred because it may run into a race condition on
    # some platforms.  Also, as with 'flock', it may not be available on some
    # systems.
    #

    if command -v flock >/dev/null; then
        if [[ "$FLOCKER" == "$lockfile" ]]; then
            locked=1
        else
            export FLOCKER=$lockfile
            exec flock "$lockfile" "$SCRIPTPATH" "${SCRIPTARGV[@]}"
        fi
    elif command -v shlock >/dev/null; then
        while true; do
            shlock -p $$ -f "$lockfile" && locked=1 && break
            sleep 1
        done
    else
        logger FAIL "No locking command available"
    fi

    (( locked ))
}


function repeat() {
    local char=$1
    local count=$2

    printf "${char}%.0s" $(seq "$count")
}


##############################################################################
# ENTRY POINT

main "$@"
